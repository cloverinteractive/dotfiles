" XDG support

if empty($MYVIMRC) | let $MIVIMRC = expand('<sfile>:p') | endif

if empty($XDG_CACHE_HOME)  | let $XDG_CACHE_HOME  = $HOME."/.cache"       | endif
if empty($XDG_CONFIG_HOME) | let $XDG_CONFIG_HOME = $HOME."/.config"      | endif
if empty($XDG_DATA_HOME)   | let $XDG_DATA_HOME   = $HOME."/.local/share" | endif
if empty($XDG_STATE_HOME)  | let $XDG_STATE_HOME  = $HOME."/.local/state" | endif

set runtimepath^=$XDG_CONFIG_HOME/vim
set runtimepath+=$XDG_DATA_HOME/vim
set runtimepath+=$XDG_CONFIG_HOME/vim/after

set packpath^=$XDG_DATA_HOME/vim,$XDG_CONFIG_HOME/vim
set packpath+=$XDG_CONFIG_HOME/vim/after,$XDG_DATA_HOME/vim/after

let g:netrw_home = $XDG_DATA_HOME."/vim"
call mkdir($XDG_DATA_HOME."/vim/spell", 'p', 0700)

set backupdir=$XDG_STATE_HOME/vim/backup | call mkdir(&backupdir, 'p', 0700)
set directory=$XDG_STATE_HOME/vim/swap   | call mkdir(&directory, 'p', 0700)
set undodir=$XDG_STATE_HOME/vim/undo     | call mkdir(&undodir,   'p', 0700)
set viewdir=$XDG_STATE_HOME/vim/view     | call mkdir(&viewdir,   'p', 0700)

if !has('nvim') " Neovim has its own special location
  set viminfofile=$XDG_STATE_HOME/vim/viminfo
endif

"

scriptencoding utf-8

" needs to be first line
set nocompatible

filetype off

call plug#begin('~/.vim/plugged')
Plug 'neoclide/coc.nvim', {'branch': 'release'}
Plug 'elmcast/elm-vim'
Plug 'tpope/vim-fugitive'
Plug 'tpope/vim-markdown'
Plug 'tpope/vim-rails'
Plug 'tpope/vim-surround'
Plug 'tpope/vim-repeat'
Plug 'vim-airline/vim-airline'
Plug 'vim-airline/vim-airline-themes'
Plug 'vim-scripts/nginx.vim'
Plug 'vim-scripts/haskell.vim'
Plug 'vim-scripts/LargeFile'
Plug 'mattn/emmet-vim'
Plug 'jinfield/vim-nginx'
Plug 'scrooloose/nerdcommenter'
Plug 'mxw/vim-jsx'
Plug 'lilydjwg/colorizer'
Plug 'styled-components/vim-styled-components'
Plug 'junegunn/fzf', { 'do': './install --bin' }
Plug 'junegunn/fzf.vim'

" Themes
Plug 'dracula/vim'

Plug 'preservim/nerdtree'
Plug 'jparise/vim-graphql'
Plug 'reasonml-editor/vim-reason-plus'
Plug 'airblade/vim-gitgutter'

call plug#end()

filetype plugin indent on

" Because we care for your eyes
set background=dark
colorscheme koehler
syntax on

if filereadable(expand("~/.vim/before"))
  source ~/.vim/before
endif

set hidden
set relativenumber
set ts=2 sts=2 sw=2 expandtab
set showtabline=2
set noshowmode

" Because it never works well
setglobal nobomb

" Lots of history
set history=1000

" Don't include hidden buffers in autocomplete
set complete=.,b,u,t

" Make cmdline tab completion similar to bash
set wildmode=list:longest

" I'm pretty sure this works for everyone
set term=screen-256color

" Shorter messages
set shortmess+=I

if has('mouse')
  set mouse=a
endif

" Lets use smartcase
set smartcase

" No wrapping please
set nowrap

" Don't resize split views automatically
set noequalalways

" Always show status line
set laststatus=2

" Enable ctrl-n and ctrl-p to scroll thru matches
set wildmenu

"stuff to ignore when tab completing
set wildignore=*.o,*.obj,*~

" Minimal lines above and below the cursor
set scrolloff=5

" Minimal number of lines to scroll when the cursor gets off the screen
set scrolljump=5

" No toolbars
set guioptions=i

" Only render when necessary
set lazyredraw

" Autoindent because lazy
set autoindent

" Backspace over indent,eol,start
set backspace=indent,eol,start

" Use symbols to represent white space
set list
set listchars=tab:➙.,trail:·,extends:❱,precedes:❰,nbsp:░

" Set enconding and file encoding to utf-8
set encoding=utf-8
set fileencoding=utf-8

" Remap leader to space
let mapleader = " "

" Remove highlights after searching
nmap <silent> <leader>/ :nohlsearch<CR>

" Change working directory to the current one
cmap cwd lcd %:p:h
cmap cd. lcd %:p:h

" Make lists easier to fill
inoremap {<CR>  {<CR>}<Esc>O<tab>
inoremap (<CR>  (<CR>)<Esc>O<tab>
inoremap [<CR>  [<CR>]<Esc>O<tab>

" When G is used don't stick to bottom
nn G G10<c-e>

" Autoescape motion
imap jj <esc>

" Shift enter, creates two lines and indents one above
inoremap <s-cr> <cr><cr><up><tab>

" Handle trailing whitespace, shamelessly taken from http://vimcasts.org/episodes/tidying-whitespace/
function! <SID>StripTrailingWhitespaces()
    " Preparation: save last search, and cursor position.
    let _s=@/
    let l = line(".")
    let c = col(".")
    " Do the business:
    %s/\s\+$//e
    " Clean up: restore previous search history, and cursor position
    let @/=_s
    call cursor(l, c)
endfunction

autocmd BufWritePre *.rb,*.coffee,*.yml,*.haml,*.erb,*.php,*.java,*.py,*.js,*.html,*.eco :call <SID>StripTrailingWhitespaces() " Run this method on save

" Surround
" Use v or # to get a variable interpolation (inside of a string)}
" ysiw# Wrap the token under the cursor in #{}
" v...s# Wrap the selection in #{}
let g:surround_113 = "#{\r}" " v
let g:surround_35 = "#{\r}" " #

" Matchit is included in vim, it only needs to be activated
runtime macros/matchit.vim

" Tag bar is toggled with f8
nmap <F8> :TagbarToggle<CR><C-W>l

if filereadable(expand("~/.vim/after"))
  source ~/.config/vim/after
endif


let g:closetag_html_style=1
autocmd FileType jsx,html,xhtml,xml,htmldjango,jinjahtml,eruby,mako,eco silent!

let g:NERDTreeDirArrowExpandable = '►'
let g:NERDTreeDirArrowCollapsible = '▼'

" vim: filetype=vim
